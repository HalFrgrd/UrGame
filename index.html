<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Royal Game of Ur</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        backgroundColor: '#FAF8EF',
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);

    //Geometry
    var boardPolygon1;
    var boardPolygon2;
    var lines;
    var rosettes;

    var piecesInPos = Array(24); // piecesInPos[i] contains the piece(s) that are in position i in the board diagram.
    for (let i = 0; i < piecesInPos.length; i++) { piecesInPos[i] = []; }
    var finishedWhites = 0; //number of pieces that white has finished;
    var finishedBlacks = 0;
    var yetToStartWhites = 7;
    var yetToStartBlacks = 7;
    const gridWidth = 48;
    var diceRoll = 1;
    var diceText;
    var dice;
    var rollAnim;
    var turnPiece = "white_token";
    var turnText;

    function preload ()
    {
       this.load.image('black_token', 'assets/black_token.png');
       this.load.image('white_token', 'assets/white_token.png');
       this.load.spritesheet('dice','assets/dice.png', {frameWidth: 100, frameHeight: 100});

    }

    function create ()
    {

      var circle = new Phaser.Geom.Circle(400,300,100);


      lines = [
        new Phaser.Geom.Line(gridWidth*1, gridWidth*2, gridWidth*9, gridWidth*2),
        new Phaser.Geom.Line(gridWidth*1, gridWidth*3, gridWidth*9, gridWidth*3),
        new Phaser.Geom.Line(gridWidth*2, gridWidth*1, gridWidth*2, gridWidth*4),
        new Phaser.Geom.Line(gridWidth*2, gridWidth*1, gridWidth*2, gridWidth*4),
        new Phaser.Geom.Line(gridWidth*4, gridWidth*2, gridWidth*4, gridWidth*3),
        new Phaser.Geom.Line(gridWidth*6, gridWidth*1, gridWidth*6, gridWidth*4),
        new Phaser.Geom.Line(gridWidth*7, gridWidth*1, gridWidth*7, gridWidth*4),
        new Phaser.Geom.Line(gridWidth*8, gridWidth*1, gridWidth*8, gridWidth*4),
      ]
      rosettes = [
        new Phaser.Geom.Line(gridWidth*2.5, gridWidth*1.5, gridWidth/2.5, 0xfff000),
        new Phaser.Geom.Line(gridWidth*8.5, gridWidth*1.5, gridWidth/2.5),
        new Phaser.Geom.Line(gridWidth*2.5, gridWidth*3.5, gridWidth/2.5),
        new Phaser.Geom.Line(gridWidth*8.5, gridWidth*3.5, gridWidth/2.5),
        new Phaser.Geom.Line(gridWidth*5.5, gridWidth*2.5, gridWidth/2.5),
      ]

      graphics = this.add.graphics({ lineStyle: { width: 2, color: 0xBBADA0 }, fillStyle: {color: 0xCDC0B4} });

      graphics.fillRoundedRect(gridWidth*1, gridWidth*1, gridWidth*2, gridWidth*3, 8,);
      graphics.fillRoundedRect(gridWidth*5, gridWidth*1, gridWidth*4, gridWidth*3, 8,);
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        graphics.strokeLineShape(line);
      }
      // graphics.strokeCircle(gridWidth*2.5, gridWidth*1.5, gridWidth/2.5)
      const starCoords = [[24,24],[24,6],[40,15],[40,33],[24,42],[8,33],[8,15]].reverse();

      function buildRosette(x,y){
        // for (let i = 0; i < starCoords.length; i++) {
        //   const coords = starCoords[i].slice;
          graphics.strokeCircle(x + starCoords[0],y + starCoords[1], 8);
        // }
      }

      buildRosette(gridWidth*2, gridWidth*1);

      //initialising dice
      dice = this.add.group();
      dice.create(gridWidth/2,gridWidth*1/2,'dice').setScale(0.4);
      dice.create(gridWidth/2,gridWidth*3/2,'dice').setScale(0.4);
      dice.create(gridWidth/2,gridWidth*5/2,'dice').setScale(0.4);
      dice.create(gridWidth/2,gridWidth*7/2,'dice').setScale(0.4);
      diceText = this.add.text(12,gridWidth*4 ,diceRoll, { fontSize: '32px', fill: '#000' });


      //initialising text
      turnText = this.add.text(48, 16, `turn: ${turnPiece}`, { fontSize: '32px', fill: '#000' });

      //initialising pieces
      whitePieces = this.add.group();
      blackPieces = this.add.group();
      for (let i = 0; i < starCoords.length; i++) {
        const coord = starCoords[i].slice();
        whitePieces.create(coord[0] + 4*gridWidth,coord[1] + 3*gridWidth, "white_token");
      }
      for (let i = 0; i < starCoords.length; i++) {
        const coord = starCoords[i].slice();
        blackPieces.create(coord[0] + 4*gridWidth,coord[1] + 1*gridWidth, "black_token");
      }
      Phaser.Actions.Call(whitePieces.getChildren(), function(sprite) {
        sprite.setScale(0.05);
      });
      Phaser.Actions.Call(blackPieces.getChildren(), function(sprite) {
        sprite.setScale(0.05);
      });

      piecesInPos[0]  = whitePieces.getChildren();
      piecesInPos[16] = blackPieces.getChildren();
      
      rollAnim = this.anims.create({
        key: 'roll',
        frames: this.anims.generateFrameNumbers('dice'),
        frameRate: 20,
        
        duration: 200,
      })

      var _this = this;
      
      
      //action to take on pointer down
      this.input.on('pointerdown', function (pointer){ //eventually pointer over to see possible move
          var boardPos = mouseXYtoBoardPos(pointer.x, pointer.y);

          if(boardPos >= 0 && piecesInPos[boardPos].length > 0){ //clicked on board and on some piece
            const colorOfPiece = piecesInPos[boardPos][piecesInPos[boardPos].length -1].texture.key;
            if(colorOfPiece != turnPiece) return;
            console.log("dice roll is", diceRoll);
            var possiblePos = possibleMove(boardPos, diceRoll, colorOfPiece);

            if(possiblePos.length > 0 ){ //there is a legal move
              if(boardPos ==  0) {yetToStartWhites -= 1}
              if(boardPos == 16) {yetToStartBlacks -= 1}

              const newPos = possiblePos[0]; //the legal move
              console.log("moving to", newPos);

              //update our knowledge of where the piece is
              piecesInPos[newPos].push(piecesInPos[boardPos].pop());

              //update the sprites position
              var newCoordinates;
              if(newPos == 15){ //special cases for when white and black are finishing
                console.log("here")
                newCoordinates = starCoords[6-finishedWhites].slice();
                newCoordinates[0] += 3*gridWidth;
                newCoordinates[1] += 3*gridWidth;
                finishedWhites++;
                console.log(newCoordinates,finishedWhites);
              } else if(newPos == 23){
                newCoordinates = starCoords[6-finishedBlacks].slice();
                newCoordinates[0] += 3*gridWidth;
                newCoordinates[1] += 1*gridWidth;
                finishedBlacks++;
              }
              else{ //this is not a finishing move
                if(piecesInPos[newPos].length > 1){ //we are removing a piece of a different color
                  const removedPiece = piecesInPos[newPos].shift();
                  switch (removedPiece.texture.key) {
                    case "black_token": {
                      console.log("removing black");
                      piecesInPos[16].push(removedPiece);
                      var newCoords = starCoords[yetToStartBlacks].slice();
                      yetToStartBlacks++;
                      newCoords[0] += 4*gridWidth;
                      newCoords[1] += 1*gridWidth;
                      break
                    }
                    case "white_token": {
                      piecesInPos[0].push(removedPiece);
                      var newCoords = starCoords[yetToStartWhites].slice();
                      yetToStartWhites++;
                      newCoords[0] += 4*gridWidth;
                      newCoords[1] += 3*gridWidth;
                      break
                    }
                  }
                  console.log("going to ", newCoords)
                  _this.tweens.add({
                  targets: removedPiece,
                      x: newCoords[0],
                      y: newCoords[1],
                      scaleX: 0.05,
                      scaleY: 0.05,
                      duration: 200,
                      ease: 'Linear',
                  });

                } 
                newCoordinates = boardPosToXY(newPos);
              }
              
              _this.tweens.add({
                  targets: piecesInPos[newPos][piecesInPos[newPos].length-1],
                  x: newCoordinates[0],
                  y: newCoordinates[1],
                  scaleX: ((newPos == 23 || newPos == 15) ? 0.05 :0.2),
                  scaleY: ((newPos == 23 || newPos == 15) ? 0.05 :0.2),
                  duration: 200,
                  ease: 'Linear',
                  onComplete: rollDice
              });
              

              if(turnPiece == "white_token") {console.log("here"); turnPiece = "black_token"}
              else if(turnPiece == "black_token") {turnPiece = "white_token"}
              turnText.setText("turn: " + turnPiece)
            }
          }          
      });
    }

    // +------+-------+              +------+-------+------+------+
    // |      |       |              |      |       |      |      |
    // |  21  |   22  |  23     16   |  17  |  18   |  19  |  20  |
    // |      |       |              |      |       |      |      |
    // +---------------------+------------------------------------+
    // |      |       |      |       |      |       |      |      |
    // |   12 |   11  |  10  |   9   |  8   |   7   |  6   |  5   |
    // |      |       |      |       |      |       |      |      |
    // +---------------------+------------------------------------+
    // |      |       |              |      |       |      |      |
    // |  13  |   14  |   15     0   |   1  |   2   |   3  |   4  |
    // |      |       |              |      |       |      |      |
    // +------+-------+              +------+-------+------+------+
    
    


    function rollDice() {
      const diceValues = [ Phaser.Math.Between(0,1),Phaser.Math.Between(0,1),Phaser.Math.Between(0,1),Phaser.Math.Between(0,1),];
      diceRoll = diceValues.reduce((a,b) => a+b,0);
      var i = 0;
      dice.getChildren().forEach(diceSprite => {
        diceSprite.anims.play('roll');
      });


      diceText.setText(diceRoll);
    }

    function possibleMove(bPos, diceRoll, colorOfToken) {
      var newPossPos = bPos;
      for (let i = 0; i < diceRoll; i++) {
        newPossPos = nextPosition(newPossPos,colorOfToken);
        if (newPossPos == -1) return [];
      }
      // console.log(`looking at position ${newPossPos}`);
      // console.log(`number of pieces in poss pos: ${piecesInPos[newPossPos].length }`)
      if (piecesInPos[newPossPos].length==0 || newPossPos == 15 || newPossPos == 23 || piecesInPos[newPossPos][0].texture.key != colorOfToken){ // if we have found a new possible position
        return [newPossPos];
        
      }
      return []
    }

    function nextPosition(bPos, color) {
      if(bPos == 20) return 5;
      if(bPos == 12 && color=="black_token") return 21;
      if(bPos == 15 || bPos == 23) return -1;
      return bPos+1;
    }

    var boardPositionsAndIndexes = [ [21,22,23,16,17,18,19,20],
      [12, 11, 10, 9, 8, 7, 6 ,5],
      [13, 14, 15, 0 ,1 ,2, 3, 4] ];

    function mouseXYtoBoardPos(pointx,pointy) {
      var x = Math.floor((pointx-gridWidth)/gridWidth);
      var y = Math.floor((pointy-gridWidth)/gridWidth);

      // console.log(boardPositionsAndIndexes[y][x]);
      if(0 <= x && x < 8 && 0 <= y && y < 3) {
        // console.log(boardPositionsAndIndexes[y][x]);
        return boardPositionsAndIndexes[y][x];
      } else{
        // console.log("clicked off board"); 
        return -1;
      }
    }

    function boardPosToXY(bPos) {
      var y = boardPositionsAndIndexes.findIndex( as => {return as.some( a => {return a == bPos}) });
      var x = boardPositionsAndIndexes[y].findIndex( a => {return a == bPos});

      return [(x+1.5)*gridWidth,(y+1.5)*gridWidth];
    }

    function update ()
    {
    }

</script>

</body>
</html>